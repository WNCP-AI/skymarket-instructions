---
Title: SkyMarket Expert Track Tech Stack
tags: 
  - WNCP_AI
  - ID-Ventures
  - hackathon
  - expert
  - openai
  - analytics
  - optimization
created: 2025-09-01
Description: Technical specification for the Expert Track (1 hour) advanced features building on Developer Track foundation with AI, analytics, and optimization.
MOC:
  - "[[WNCP_AI MOC]]"
  - "[[ID Ventures MOC]]"
---

# SkyMarket Expert Track Tech Stack

## Executive Summary
The Expert Track enhances the Developer Track implementation in **1 hour** by adding AI-powered features, comprehensive admin dashboard, and performance optimizations. This builds directly on the existing Convex + Next.js foundation, demonstrating how to evolve a basic marketplace into an intelligent platform with business analytics.

## Architecture Overview

### System Architecture
```
┌─────────────────────────────────────────────────────────────┐
│              Expert Track Architecture (1 hour)             │
│            (Builds on Developer Track Foundation)           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  AI Enhancement Layer                                       │
│  ├── OpenAI GPT-4 (intelligent matching)                   │
│  ├── Content optimization                                  │
│  ├── Smart pricing recommendations                         │
│  └── Automated customer support                            │
│                                                             │
│  Admin Dashboard                                           │
│  ├── Real-time analytics (Convex aggregations)             │
│  ├── User management interface                             │
│  ├── Platform moderation tools                             │
│  └── Revenue tracking & reporting                          │
│                                                             │
│  Performance Optimizations                                 │
│  ├── Advanced Convex indexes                               │
│  ├── Query result caching                                  │
│  ├── Subscription optimization                             │
│  └── Error tracking & monitoring                           │
│                                                             │
│  Business Intelligence                                     │
│  ├── Provider performance scoring                          │
│  ├── Demand analysis & forecasting                         │
│  ├── Dynamic pricing models                                │
│  └── Automated reporting                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### What Will Be Built
- **AI Integration**: Smart matching, content optimization, pricing intelligence
- **Admin Console**: Complete platform management and oversight tools
- **Analytics Dashboard**: Real-time metrics, trends, and insights
- **Performance Layer**: Optimized queries, caching, and monitoring

## AI Enhancement Features

### OpenAI Integration

#### Configuration
```typescript
// convex/ai.ts
import { action } from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Smart service matching
export const matchServiceToRequest = action({
  args: {
    requestDescription: v.string(),
    userLocation: v.object({
      lat: v.number(),
      lng: v.number(),
    }),
    preferences: v.object({
      maxPrice: v.number(),
      preferredTime: v.string(),
      urgency: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
    }),
  },
  handler: async (ctx, args) => {
    // Get nearby services
    const listings = await ctx.runQuery(api.listings.searchNearby, {
      location: args.userLocation,
      radiusMiles: 15, // Detroit Metro area
    });
    
    // Create embedding for request
    const embedding = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: args.requestDescription,
    });
    
    // Score and rank services
    const scoredListings = await Promise.all(
      listings.map(async (listing) => {
        // Generate listing embedding
        const listingEmbedding = await openai.embeddings.create({
          model: "text-embedding-3-small",
          input: `${listing.title} ${listing.description}`,
        });
        
        // Calculate similarity
        const similarity = cosineSimilarity(
          embedding.data[0].embedding,
          listingEmbedding.data[0].embedding
        );
        
        // Factor in price, availability, distance
        const priceScore = 1 - (listing.price.base / args.preferences.maxPrice);
        const distanceScore = 1 - (calculateDistance(
          args.userLocation,
          listing.serviceArea.center
        ) / 15);
        
        return {
          listing,
          score: similarity * 0.5 + priceScore * 0.3 + distanceScore * 0.2,
          explanation: await generateMatchExplanation(listing, args),
        };
      })
    );
    
    return scoredListings
      .sort((a, b) => b.score - a.score)
      .slice(0, 5);
  },
});

// Listing optimization
export const optimizeListing = action({
  args: {
    title: v.string(),
    description: v.string(),
    category: v.string(),
    targetAudience: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: `You are an expert at optimizing drone service marketplace listings for Detroit Metro area. 
                   Focus on local appeal, clear value propositions, and SEO-friendly language.`,
        },
        {
          role: "user",
          content: `Optimize this listing:
                   Title: ${args.title}
                   Description: ${args.description}
                   Category: ${args.category}
                   Target: ${args.targetAudience || 'General Detroit area residents and businesses'}`,
        },
      ],
      temperature: 0.7,
      response_format: { type: "json_object" },
    });
    
    return JSON.parse(completion.choices[0].message.content || "{}");
  },
});

// Dynamic pricing recommendations
export const recommendPricing = action({
  args: {
    category: v.string(),
    serviceArea: v.object({
      center: v.object({ lat: v.number(), lng: v.number() }),
      radiusMiles: v.number(),
    }),
    competitorCount: v.number(),
  },
  handler: async (ctx, args) => {
    // Get historical booking data
    const historicalData = await ctx.runQuery(api.analytics.getPricingData, {
      category: args.category,
      area: args.serviceArea,
    });
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: "You are a pricing strategy expert for drone services in Detroit.",
        },
        {
          role: "user",
          content: `Based on this data, recommend optimal pricing:
                   Category: ${args.category}
                   Competition: ${args.competitorCount} providers
                   Historical average: $${historicalData.avgPrice}
                   Peak demand times: ${historicalData.peakTimes}`,
        },
      ],
    });
    
    return {
      recommendedBase: parseFloat(completion.choices[0].message.content?.match(/\$(\d+\.?\d*)/)?.[1] || "0"),
      reasoning: completion.choices[0].message.content,
      dynamicFactors: {
        peakHourMultiplier: 1.5,
        weekendMultiplier: 1.2,
        badWeatherMultiplier: 1.8,
      },
    };
  },
});
```

### AI-Powered Customer Support
```typescript
// convex/support.ts
export const handleSupportQuery = action({
  args: {
    userId: v.id("users"),
    query: v.string(),
    context: v.optional(v.object({
      bookingId: v.optional(v.id("bookings")),
      listingId: v.optional(v.id("listings")),
    })),
  },
  handler: async (ctx, args) => {
    // Get user context
    const user = await ctx.runQuery(api.users.get, { id: args.userId });
    const recentBookings = await ctx.runQuery(api.bookings.getRecent, { 
      userId: args.userId 
    });
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: `You are SkyMarket support assistant for Detroit drone services.
                   Be helpful, concise, and knowledgeable about local regulations.`,
        },
        {
          role: "user",
          content: `User query: ${args.query}
                   User type: ${user.role}
                   Recent activity: ${JSON.stringify(recentBookings)}`,
        },
      ],
    });
    
    // Store interaction for analytics
    await ctx.runMutation(api.support.logInteraction, {
      userId: args.userId,
      query: args.query,
      response: completion.choices[0].message.content,
      resolved: completion.choices[0].message.content?.includes("resolved"),
    });
    
    return {
      response: completion.choices[0].message.content,
      suggestedActions: extractActions(completion.choices[0].message.content),
    };
  },
});
```

## Admin Dashboard

### Analytics Dashboard Components

#### Real-time Metrics
```typescript
// convex/analytics.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const getDashboardMetrics = query({
  args: {},
  handler: async (ctx) => {
    const now = Date.now();
    const dayAgo = now - 24 * 60 * 60 * 1000;
    const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
    
    // Parallel queries for performance
    const [
      totalUsers,
      activeProviders,
      todayBookings,
      weekBookings,
      revenue
    ] = await Promise.all([
      ctx.db.query("users").collect(),
      ctx.db.query("users")
        .withIndex("by_role", q => q.eq("role", "provider"))
        .filter(q => q.gte(q.field("lastActive"), dayAgo))
        .collect(),
      ctx.db.query("bookings")
        .withIndex("by_created", q => q.gte("createdAt", dayAgo))
        .collect(),
      ctx.db.query("bookings")
        .withIndex("by_created", q => q.gte("createdAt", weekAgo))
        .collect(),
      ctx.db.query("bookings")
        .withIndex("by_status", q => q.eq("status", "completed"))
        .filter(q => q.gte(q.field("completedAt"), weekAgo))
        .collect(),
    ]);
    
    return {
      users: {
        total: totalUsers.length,
        providers: activeProviders.length,
        growth: calculateGrowth(totalUsers),
      },
      bookings: {
        today: todayBookings.length,
        week: weekBookings.length,
        conversionRate: calculateConversionRate(weekBookings),
        avgValue: revenue.reduce((sum, b) => sum + b.payment.amount, 0) / revenue.length,
      },
      revenue: {
        week: revenue.reduce((sum, b) => sum + b.payment.amount, 0),
        platformFees: revenue.reduce((sum, b) => sum + b.payment.amount * 0.15, 0),
        projectedMonth: projectMonthlyRevenue(revenue),
      },
      performance: {
        avgResponseTime: calculateAvgResponseTime(weekBookings),
        completionRate: weekBookings.filter(b => b.status === "completed").length / weekBookings.length,
        satisfaction: calculateSatisfactionScore(weekBookings),
      },
    };
  },
});

// User management
export const getUserAnalytics = query({
  args: {
    role: v.optional(v.union(v.literal("consumer"), v.literal("provider"))),
    sortBy: v.optional(v.union(
      v.literal("bookings"),
      v.literal("revenue"),
      v.literal("rating")
    )),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let query = ctx.db.query("users");
    
    if (args.role) {
      query = query.withIndex("by_role", q => q.eq("role", args.role));
    }
    
    const users = await query.take(args.limit || 100);
    
    // Enrich with analytics
    const enrichedUsers = await Promise.all(
      users.map(async (user) => {
        const bookings = await ctx.db.query("bookings")
          .withIndex(
            user.role === "provider" ? "by_provider" : "by_consumer",
            q => q.eq(
              user.role === "provider" ? "providerId" : "consumerId",
              user._id
            )
          )
          .collect();
        
        const revenue = bookings
          .filter(b => b.status === "completed")
          .reduce((sum, b) => sum + b.payment.amount, 0);
        
        return {
          ...user,
          metrics: {
            totalBookings: bookings.length,
            completedBookings: bookings.filter(b => b.status === "completed").length,
            revenue,
            avgRating: await calculateUserRating(ctx, user._id),
            lastActive: bookings[0]?.createdAt || user.createdAt,
          },
        };
      })
    );
    
    // Sort based on criteria
    if (args.sortBy) {
      enrichedUsers.sort((a, b) => {
        switch (args.sortBy) {
          case "bookings":
            return b.metrics.totalBookings - a.metrics.totalBookings;
          case "revenue":
            return b.metrics.revenue - a.metrics.revenue;
          case "rating":
            return b.metrics.avgRating - a.metrics.avgRating;
          default:
            return 0;
        }
      });
    }
    
    return enrichedUsers;
  },
});
```

#### Admin Dashboard UI
```typescript
// app/admin/dashboard/page.tsx
"use client";

import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { BarChart, LineChart, PieChart } from "@/components/charts";

export default function AdminDashboard() {
  const metrics = useQuery(api.analytics.getDashboardMetrics);
  const topProviders = useQuery(api.analytics.getUserAnalytics, {
    role: "provider",
    sortBy: "revenue",
    limit: 10,
  });
  
  if (!metrics) return <div>Loading...</div>;
  
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-3xl font-bold">SkyMarket Admin Dashboard</h1>
      
      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle>Total Users</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{metrics.users.total}</div>
            <p className="text-sm text-gray-500">
              +{metrics.users.growth}% this week
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Today's Bookings</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{metrics.bookings.today}</div>
            <p className="text-sm text-gray-500">
              ${metrics.bookings.avgValue.toFixed(2)} avg value
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Weekly Revenue</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${metrics.revenue.week.toFixed(2)}
            </div>
            <p className="text-sm text-gray-500">
              ${metrics.revenue.platformFees.toFixed(2)} fees
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Completion Rate</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {(metrics.performance.completionRate * 100).toFixed(1)}%
            </div>
            <p className="text-sm text-gray-500">
              {metrics.performance.avgResponseTime} min avg response
            </p>
          </CardContent>
        </Card>
      </div>
      
      {/* Charts */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Booking Trends</CardTitle>
          </CardHeader>
          <CardContent>
            <LineChart data={metrics.bookingTrends} />
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Service Categories</CardTitle>
          </CardHeader>
          <CardContent>
            <PieChart data={metrics.categoryBreakdown} />
          </CardContent>
        </Card>
      </div>
      
      {/* Top Providers Table */}
      <Card>
        <CardHeader>
          <CardTitle>Top Providers</CardTitle>
        </CardHeader>
        <CardContent>
          <table className="w-full">
            <thead>
              <tr>
                <th className="text-left">Provider</th>
                <th>Bookings</th>
                <th>Revenue</th>
                <th>Rating</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {topProviders?.map(provider => (
                <tr key={provider._id}>
                  <td>{provider.name}</td>
                  <td className="text-center">{provider.metrics.totalBookings}</td>
                  <td className="text-center">${provider.metrics.revenue.toFixed(2)}</td>
                  <td className="text-center">{provider.metrics.avgRating.toFixed(1)}</td>
                  <td>
                    <button className="text-blue-500 hover:underline">View</button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </CardContent>
      </Card>
    </div>
  );
}
```

## Performance Optimizations

### Advanced Indexing
```typescript
// convex/schema.ts - Additional indexes for Expert track
.index("by_category_and_price", ["category", "price.base"])
.index("by_provider_and_status", ["providerId", "status"])
.index("by_location_hash", ["locationHash"]) // Geospatial optimization
.index("by_created_date", ["createdAt"])
```

### Query Optimization
```typescript
// convex/optimized.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

// Cached aggregations
export const getCachedMetrics = query({
  args: {
    cacheKey: v.string(),
    maxAge: v.optional(v.number()), // milliseconds
  },
  handler: async (ctx, args) => {
    // Check cache
    const cached = await ctx.db
      .query("cache")
      .withIndex("by_key", q => q.eq("key", args.cacheKey))
      .first();
    
    if (cached && Date.now() - cached.timestamp < (args.maxAge || 300000)) {
      return cached.data;
    }
    
    // Compute fresh data
    const freshData = await computeMetrics(ctx, args.cacheKey);
    
    // Update cache
    if (cached) {
      await ctx.db.patch(cached._id, {
        data: freshData,
        timestamp: Date.now(),
      });
    } else {
      await ctx.db.insert("cache", {
        key: args.cacheKey,
        data: freshData,
        timestamp: Date.now(),
      });
    }
    
    return freshData;
  },
});

// Subscription optimization
export const getOptimizedBookingUpdates = query({
  args: {
    bookingId: v.id("bookings"),
    lastUpdate: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const booking = await ctx.db.get(args.bookingId);
    
    // Only return if changed since last update
    if (args.lastUpdate && booking?.updatedAt <= args.lastUpdate) {
      return { changed: false };
    }
    
    return {
      changed: true,
      booking,
      timestamp: Date.now(),
    };
  },
});
```

### Error Tracking
```typescript
// convex/monitoring.ts
export const logError = mutation({
  args: {
    error: v.object({
      message: v.string(),
      stack: v.optional(v.string()),
      userId: v.optional(v.id("users")),
      context: v.optional(v.any()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("errors", {
      ...args.error,
      timestamp: Date.now(),
      resolved: false,
    });
    
    // Alert if critical
    if (args.error.message.includes("payment") || 
        args.error.message.includes("critical")) {
      await sendAlertToAdmin(args.error);
    }
  },
});
```

## Business Intelligence Features

### Demand Forecasting
```typescript
// convex/forecasting.ts
export const forecastDemand = action({
  args: {
    category: v.string(),
    timeframe: v.union(v.literal("week"), v.literal("month")),
  },
  handler: async (ctx, args) => {
    // Get historical data
    const historicalBookings = await ctx.runQuery(api.analytics.getHistoricalBookings, {
      category: args.category,
      days: args.timeframe === "week" ? 28 : 90,
    });
    
    // Simple moving average forecast
    const forecast = calculateMovingAverage(historicalBookings);
    
    // Identify patterns
    const patterns = {
      peakDays: identifyPeakDays(historicalBookings),
      peakHours: identifyPeakHours(historicalBookings),
      seasonality: detectSeasonality(historicalBookings),
    };
    
    return {
      forecast,
      patterns,
      recommendations: generateRecommendations(forecast, patterns),
    };
  },
});
```

## Development Timeline (1 Hour)

### First 20 Minutes: AI Integration
```bash
# 1. OpenAI Setup (5 min)
npm install openai
# Add OPENAI_API_KEY to .env.local

# 2. AI Functions (10 min)
# Copy AI matching and optimization functions
# Add to convex/ai.ts

# 3. Test AI Features (5 min)
# Test matching algorithm
# Verify listing optimization
```

### Next 20 Minutes: Admin Dashboard
```bash
# 1. Analytics Queries (10 min)
# Add aggregation queries to convex/analytics.ts
# Create dashboard metrics functions

# 2. Admin UI (10 min)
# Create app/admin/dashboard/page.tsx
# Add charts and tables
# Implement user management interface
```

### Final 20 Minutes: Optimization & Deployment
```bash
# 1. Performance Optimization (10 min)
# Add indexes to schema
# Implement query caching
# Optimize subscriptions

# 2. Testing & Deployment (10 min)
# Test all new features
# Deploy to production
# Verify performance improvements
```

## Testing Expert Features

### AI Testing
```typescript
describe('AI Features', () => {
  it('matches services intelligently', async () => {
    const matches = await matchServiceToRequest({
      requestDescription: "Need food delivered to downtown Detroit ASAP",
      userLocation: { lat: 42.3314, lng: -83.0458 },
      preferences: { maxPrice: 50, urgency: "high" }
    });
    
    expect(matches[0].score).toBeGreaterThan(0.7);
    expect(matches[0].listing.category).toBe("food_delivery");
  });
});
```

## Estimated Additional Costs (Expert Track)

### Development Phase
- **OpenAI API**: ~$5 in testing credits
- **Additional Convex usage**: Still within free tier
- **Total**: ~$5

### Production (Added to Developer costs)
- **OpenAI API**: ~$50-100/month (depends on usage)
- **Convex**: May need paid tier at scale ($25/month)
- **Total Additional**: $75-125/month

---

## Conclusion

The Expert Track transforms the Developer Track marketplace into an intelligent platform in just 1 hour. By adding AI-powered matching, comprehensive analytics, and performance optimizations, participants learn how to evolve a basic application into a sophisticated business platform. The modular approach ensures all features integrate seamlessly with the existing Convex foundation.

---

*This document serves as the complete technical guide for the Expert Track enhancement of SkyMarket.*